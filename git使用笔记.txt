记录 Git 的使用笔记

===== 本地删除文件后,让服务器也删除这个文件: git add -u
使用 man git-add 查看它的帮助手册,里面对 -u 选项的说明如下:
-u, --update
    Only match <filepattern> against already tracked files in the index
    rather than the working tree. That means that it will never stage
    new files, but that it will stage modified new contents of tracked
    files and that it will remove files from the index if the
    corresponding files in the working tree have been removed.

    If no <filepattern> is given, default to "."; in other words, update
    all tracked files in the current directory and its subdirectories.

===== 查看上库的文件名,但不打印具体的改动: git log --name-status
--name-status
    Show only names and status of changed files.

===== 使用git库的版本覆盖本地修改: git checkout 和 git reset
git checkout -- <filename>: 可以恢复还没有执行 git add 的文件
git reset HEAD <filename>: 对于已经执行git add的文件,使用这个命令取消add,
                           然后再使用上一条命令恢复
git reset --hard HEAD: 把全部更改的文件都恢复.
--hard
    Resets the index and working tree. Any changes to tracked files in the
    working tree since <commit> are discarded. 上面的HEAD就是一个<commit>

实际使用发现,git checkout 和 git reset 有如下的区别:
(1)直接用 git checkout 将代码回退到之前的提交时,当前的 git 分支会发生改变,
得到一个未命名分支,提示用"git checkout -b new_branch_name"生成新分支.例如:
$ git branch
* (no branch)
  master
虽然,当前目录已经被回退为之前的提交,但是这个改动不是发生在原来的分支上,而是
要切换出新的分支.当执行 git checkout branch_name 命令切回原来分支时,原来分
支的代码没有回退.            如果想直接回退当前分支的代码,不能采用这种做法.
(2)使用 git reset 将代码log回退到之前的提交时,当前的 git 分支不会发生改变,
不会得到一个未命名分支,当前目录下的代码不会被回退.此时使用 git status 命令
查看 git 仓库状态,一般会提示部分文件有所改动,即当前代码和git暂存区中的代码
不符.暂存区中的代码是 git reset 所回退到的log记录的代码,当前代码是最新改动
的代码.如果想将当前代码回退,可以再使用 git checkout 命令来覆盖当前的改动.
即,如果想在当前分支上,将本地代码回退,就可以使用这种方法.它不会生成新的分支.

===== 查看某个人的上库信息: git log --author=<pattern>, --committer=<pattern>
--author=<pattern>, --committer=<pattern>
    Limit the commits output to ones with author/committer header lines
    that match the specified pattern (regular expression).
    也就是说,这个pattern可以是正则表达式,可以指定人名,也可以指定邮箱.
例如,使用git log --author=john查看john的上库信息.如果有多个john,也可以使用
git log --author=john@example.com来查看这个邮箱的上库信息.
该选项可以使用正则表达式,如果想匹配任意 "@example.com" 这个邮箱上库的log,可
以使用命令: git log --author=".example"或者git log --author=".example.com".

===== 查找上库注释: git log --grep=<pattern>
--grep=<pattern>
    Limit the commits output to ones with log message that matches the
    specified pattern (regular expression).
使用这个命令可以根据上库注释过滤git log.

===== 解决git status显示中文文件名乱码问题
$ git status
# 位于分支 master
# 尚未暂存以备提交的变更:
#   （使用 "git add <file>..." 更新要提交的内容）
#   （使用 "git checkout -- <file>..." 丢弃工作区的改动）
#
#   修改:      "5-\224\257\346\216\247\345\210\266\346\265\201.txt"
可以看到,使用 git status 查看改动时,显示的中文文件名乱码
解决方案是: git config --global core.quotepath false

===== 强制覆盖服务器的git log信息
-f, --force
    Usually, the command refuses to update a remote ref that is not an
    ancestor of the local ref used to overwrite it. This flag disables
    the check. This can cause the remote repository to lose commits;
    use it with care.
当我们回退本地git log,重新提交后,使用git push会报错,打印类似的错误信息:
    ---- 提示:更新被拒绝,因为您当前分支的最新提交落后于其对应的远端分支.
此时,如果想强制用本地git log覆盖服务器的git log,可以使用 git push -f 命令.

===== 只查看前 N 条log信息
-<n>
    Limits the number of commits to show. Note that this is a commit
    limiting option.
使用 git log HEAD 命令并不会只输出第一条log,而是会输出所有log. 如果想查看
只查看第一条log,可以使用 git log -1 命令(注意,是数字1,而不是字母l).如果想
查看前面三条log,则使用 git log -3 命令.注意,这个命令不是打印第三条log的意
思,而是打印前面三条log.

===== 删除远端服务器分支
有两种可以用于删除远端服务器上的分支:
(1)git push origin :<branchName>: 推送一个空分支到远端分支,从而删除远端分支
(2)git push origin --delete <branchName>: 本质上和第一种方法是一样的.
man git-push可以看到,里面对 --delete 选项的描述为:
    All listed refs are deleted from the remote repository. This is the
    same as prefixing all refs with a colon.

===== 同时添加修改的文件和删除的文件到暂存区
如果对当前目录下的文件进行修改,可以使用 git add . 命令来添加这些文件到暂存
区,但是这个命令不能添加被删除的文件.要添加被删除的文件,需要使用git add -u .
命令.也就说,如果当前目录下有的文件被修改,有的文件被删除时,要添加它们到暂存
区,需要分别执行两个 "git add ." 和 "git add -u ." 命令.其实,还有一个更简单
的方法,那就是使用 git add 命令的 -A 选项:
-A, --all
    Like -u, but match <filepattern> against files in the working tree
    in addition to the index. That means that it will find new files as
    well as staging modified content and removing files that are no
    longer in the working tree.
即使用 -A或--all 选项,就能同时添加修改过的文件和删除的文件到暂存区.

===== 设置命令别名
打开.gitconfig文件,添加如下设置项:
[alias]
    co = checkout
    ci = commit
    st = status
    pl = pull
    ps = push
    dt = difftool
    l = log --stat
    cp = cherry-pick
    ca = commit -a
    b = branch

===== 执行git pull命令会拉取服务器所有branch、tag的信息,如果想只拉取当前branch的
信息,要再加上远端仓库名和branch名作为参数.例如,将远端origin仓库的xx分支合并到
本地当前分支,可以执行这个命令: git pull origin xx
如果还要不拉tag信息,可以再加上 --no-tags 选项
对repo来说,可以执行 repo forall -c git pull --no-tags origin xx 命令从远端
对origin仓库拉取xx分支,且不会拉取远端其他branch、tag的信息

===== 当修改文件时,特别是在Windows下修改Linux的文件,可能会改变文件的mode属性值,
例如从644变成755,然后使用git add命令添加文件,会提示file mode change,但是
这个提示不太明显,容易被忽略,如果只是想看文件mode是否发生改变,可以使用git diff
命令的--summary选项.man git-diff手册对这个选项的说明如下:
  Output a condensed summary of extended header information such as
  creations, renames and mode changes.
例如,如果本地文件的mode改变了,执行git diff --summary命令,会看到类似下面的信息:
 mode change 100755 => 100644 file_name
这样的信息,不会列出文件内容的改动,只列出文件mode变化,方便只查看到mode的变化.

git log命令也有 --summary 选项可以查看已经提交的文件mode变化.

===== git pull 是否打印改动的文件信息
在公司的Android代码目录里面,使用git pull命令,发现不会打印发生改变的文件信息.
例如不会打印类似下面的信息:
Fast-forward
 res/values-zh-rCN/strings.xml                                         | 5 +++--
 res/values/strings.xml                                                | 4 ++--
 src/com/android/settings/deviceinfo/SoftwarePreferenceController.java | 2 +-
 3 files changed, 6 insertions(+), 5 deletions(-)
但是上一家公司的 git pull 命令会打印改动的文件信息,需要确认出现这种差异的原因.

经过确认,这是因为 git pull 执行的是 git rebase 所引起.
在git仓库目录下执行 git config -l 命令,看到有如下配置:
    pull.rebase=true
这是当前代码目录的git仓库里面自行配置的.
使用 git config --global -l 查看没有这个配置.

查看 man git-config 命令的说明,pull.rebase=true 表示 git pull 使用 git rebase,
而不是使用 git merge.具体的说明如下:
  pull.rebase
    When true, rebase branches on top of the fetched branch, instead of
    merging the default branch from the default remote when "git pull" is run.

再查看 man git-rebase 命令的说明:
   rebase.stat
       Whether to show a diffstat of what changed upstream since
       the last rebase. False by default.
   --stat
       Show a diffstat of what changed upstream since the last rebase. The
       diffstat is also controlled by the configuration option rebase.stat.
   -n, --no-stat
       Do not show a diffstat as part of the rebase process.
即,git rebase 默认不会打印发生变动的文件名.
如果想要打印,需要添加 --stat 选项.

作为对比,git merge命令默认会打印修改前后的文件名.下面是man git-merge命令的说明:
   --stat, -n, --no-stat
       Show a diffstat at the end of the merge. The diffstat is also
       controlled by the configuration option merge.stat.
       With -n or --no-stat do not show a diffstat at the end of the merge.

   merge.stat
       Whether to print the diffstat between ORIG_HEAD and the merge result
       at the end of the merge. True by default.

总的来说,git pull 命令其实是先使用 git fetch 获取远端代码,然后调用 git merge
把获取到的远端代码合并到本地分支.如果提供了 --rebase 选项,会用 git rebase 来
替代 git merge.配置 pull.rebase 为true,git pull 默认会用 git rebase.
当使用 git merge 时,默认会打印变动的文件信息.
而使用 git rebase 时,默认不会打印变动的文件信息.

===== git pull的多次测试方法
执行git pull后,本地仓库已经跟远端服务器保存一致,如果想要多次测试git pull的
效果,需要先让本地仓库代码落后于远端服务器代码.具体方法说明如下.

先执行 git checkout -b local_branch_name HEAD~2 命令,
或者执行 git checkout -b local_branch_name commit 命令.
HEAD是指当前的快照,HEAD~1指回退一个快照,可以简写为HEAD~,HEAD~2指回退两个快照.
依次类推,可以指定本地分支要落后于服务器多少个快照.
commit是git commit的hash值,通过commit来指定要回退到哪一个提交.
这两个命令的作用是,创建一个新的分支,且新分支的代码已经落后于远端服务器代码

接下来用 git pull remote_repository remote_branch_name 来更新代码,就能看到
git pull 的更新效果.这里如果只执行 git pull,会报下面的错误:
fatal: No remote repository specified.  Please, specify either a URL or a
remote name from which new revisions should be fetched.

当这样pull之后,当前本地分支代码已经最新,再次pull就没有新的改动.
如果想要再测试pull效果,可以再创建新的本地分支.

上面checkout的时候也可以先不加 -b 选项,先执行 git checkout HEAD~2 或者
git checkout commit 命令,执行之后,当前就不处于任何分支下,git提示可以用
git checkout -b new_branch_name 来创建新的本地分支,然后再用上面的方法来pull.

如果不想多次创建新的分支,想在当前的本地分支上多次测试git pull,可以参考下面方法.
先执行 git reset commit 命令,commit是git commit的hash值,指定要回退到哪一个提交,
那么本地代码会被回退,用 git status 命令查看,会看到有一些文件还没有被提交,此时
无法执行 git pull,会提示 "Cannot pull with rebase: You have unstaged changes."

接下来需要重新执行 git add、git commit 进行提交,之后就可以用
git pull remote_repository remote_branch_name 命令来更新.
此时,如果git pull用的是git merge就会提示branch merge,自动弹出merge comment,需要确认.
如果git pull用的是git rebase,不会提示branch merge,不需要填写或确认merge comment.

===== git pull 命令的选项顺序问题
实际使用 git pull 的时候,遇到这样一个问题,当把 --stat 写在 --no-tags 后面执行会报错:
$ git pull --no-tags --stat aosp remote_branch_name
error: unknown option `stat'

但是把 --stat 和 --no-tags 的顺序调换,执行 git pull 命令不会报错:
$ git pull --stat --no-tags aosp remote_branch_name
From ssh://10.15.208.10:29418/platform/packages/apps/Settings
 * branch            remote_branch_name -> FETCH_HEAD
Current branch remote_branch_name is up to date.

即,--stat 必须写在 --no-tags 前面,否则 git pull 就会报错.
查看 man git-pull 的帮助说明,对此解释如下:
More precisely, git pull runs git fetch with the given parameters and calls
git merge to merge the retrieved branch heads into the current branch.
With --rebase, it runs git rebase instead of git merge.
Options meant for git pull itself and the underlying git merge must be given
before the options meant for git fetch.
--stat 是 merge/rebase 的选项,--no-tags 是 fetch 的选项.基于上面说明,merge选项
必须写在fetch选项前面.所以当 --stat 写在 --no-tags 后面时,git pull会报错,它应该
是把--stat传给git fetch处理,但是git fetch没有这个选项,报错提示"unknown option".

===== 打印且只打印本地分支名
使用 git branch 查看分支,会打印仓库下的所有分支名,通过'*'星号来标识当前分支.
如果想打印且打印当前本地分支名,可以用 git symbolic-ref --short HEAD 命令.
$ git branch
* curent_branch_xxx
  enable_func
$ git symbolic-ref --short HEAD
curent_branch_xxx

使用 git rev-parse --abbrev-ref HEAD 命令也是打印且只打印当前分支名.
$ git rev-parse --abbrev-ref HEAD
curent_branch_xxx

这两个命令便于在shell脚本中获取当前分支名,做一些自动化处理.

使用 man git-symbolic-ref 查看该命令的帮助信息,说明如下.
git symbolic-ref: Read, modify and delete symbolic refs
  git symbolic-ref [-m <reason>] <name> <ref>
  git symbolic-ref [-q] [--short] <name>
    Given one argument, reads which branch head the given symbolic ref refers to
    and outputs its path, relative to the .git/ directory. Typically you would
    give HEAD as the <name> argument to see which branch your working tree is on.

  --short
    When showing the value of <name> as a symbolic ref, try to shorten the value,
    e.g. from refs/heads/master to master.
即,git symbolic-ref 命令可以查看 symbolic ref 的信息.
而HEAD就是一个symbolic ref的名称,可用于查看当前工作分支.

使用 man git 可以查看到 git refs、HEAD 的一些说明.
  Named pointers called refs mark interesting points in history. A ref may contain
  the SHA-1 name of an object or the name of another ref. Refs with names beginning
  ref/head/ contain the SHA-1 name of the most recent commit (or "head") of a branch
  under development. SHA-1 names of tags of interest are stored under ref/tags/.
  A special ref named HEAD contains the name of the currently checked-out branch.

查看 github 网站上的开发者文档,有如下说明.
https://developer.github.com/v3/git/refs/
A Git reference (git ref) is just a file that contains a Git commit SHA-1 hash. When
referring to a Git commit, you can use the Git reference, which is an easy-to-remember
name, rather than the hash. The Git reference can be rewritten to point to a new commit.
A branch is just a Git reference that stores the new Git commit hash.

即,git ref 是保存了git commit hash值,git ref本身有一个名称,被用作分支名.
一个分支其实就是一个git ref.不同分支的差异是分支head指向的git commit hash不同.
HEAD是一个指向当前工作分支的git ref,切换工作分支,会改变HEAD的指向.这个文件在
git仓库中的路径是 .git/HEAD,可以用cat命令查看它的内容,下面的HEAD指向master分支:
    $ cat .git/HEAD
    ref: refs/heads/master
各个git ref存在 .git/refs/ 目录下,本地分支head存在 .git/refs/heads/ 目录下:
    $ ls .git/refs/heads
    great  master
可以看到,git branch 的分支名跟 .git/refs/heads/ 目录下的文件名相同:
    $ git branch
      great
    * master

结合这几个说明,对 git symbolic-ref --short HEAD 命令分解说明如下.
git symbolic-ref 命令可以解析获取 git ref 的信息
--short 表示获取 symbolic ref 的名称
HEAD 是指向当前工作分支的 git ref,解析HEAD文件信息,就能获取当前分支名.

git rev-parse --abbrev-ref HEAD命令也能获取当前分支名,查看man git-rev-parse说明如下.
git rev-parse: Pick out and massage parameters
  git rev-parse [ --option ] <args>...
  Options for Output
    --abbrev-ref[=(strict|loose)]
        A non-ambiguous short name of the objects name.
man手册里面没有具体说明这个命令的表现是什么.在git的参考手册上找到一些描述.
https://git-scm.com/book/en/v2/Git-Tools-Revision-Selection
If you want to see which specific SHA-1 a branch points to, or if you want to see what
any of these examples boils down to in terms of SHA-1s, you can use a Git plumbing tool
called rev-parse; basically, rev-parse exists for lower-level operations and isn’t
designed to be used in day-to-day operations.

大致理解,git rev-parse 是一种git管道(plumbing)工具,可用于处理SHA-1 hash值.
我们在上面看到,git rev-parse --abbrev-ref HEAD 打印当前分支名,--abbrev-ref 表示输出
所给对象的、不会混淆的短名,类似于 git symbolic-ref 的 --short 选项的输出结果.
不加 --abbrev-ref 时,会打印出HEAD对应的hash值.
$ git rev-parse HEAD
8ebf0117f9545187d3368adc1ce629608214984a

这两个命令都可以打印当前分支名,如果当前没有命名分支时,它们的行为会有一些差异.
下面用git branch命令查看,可以看到当前处在分离的HEAD状态下,当前分支没有命名.
    $ git branch
    * (detached from 65c6917)
      great
      master
在这种情况下,HEAD不是符号引用,git symbolic-ref会以错误退出
    $ git symbolic-ref --short HEAD
    fatal: ref HEAD is not a symbolic ref
而git rev-parse –abbrev-ref将HEAD解析为自身.
    $ git rev-parse --abbrev-ref HEAD
    HEAD

===== 获取当前本地分支对应的远端服务器分支
可以使用下面命令查看本地分支在远端服务器的分支名
    git rev-parse --abbrev-ref local_branch_name@{upstream}
把 local_branch_name 换成要查询的本地分支名,例如 master 等.下面举例说明如下.

先创建一个新的本地分支,名为 new_local_branch,关连到远端服务器的Remote_Branch_U分支
    $ git checkout -b new_local_branch aosp/Remote_Branch_U
    Branch new_local_branch set up to track remote branch Remote_Branch_U from aosp.
    Switched to a new branch 'new_local_branch'
查看本地分支 new_local_branch 在远端服务器的分支名
    $ git rev-parse --abbrev-ref new_local_branch@{upstream}
    aosp/Remote_Branch_U

如果所给的本地分支名没有关连到远端服务器分支,会打印报错信息.
    $ git rev-parse --abbrev-ref great@{upstream}
    fatal: No upstream configured for branch 'great'

注意, "@{upstream}" 这一整串本身是命令的一部分,直接输入即可,不是要把upstream或者
{upstream}替换成远端服务器仓库名.查看 man git-rev-parse,有如下说明.
  <branchname>@{upstream}, e.g. master@{upstream}, @{u}
      The suffix @{upstream} to a branchname (short form <branchname>@{u}) refers
      to the branch that the branch specified by branchname is set to build on top
      of. A missing branchname defaults to the current one.
即,@{upstream} 可以缩写为 @{u}.如果不提供分支名,默认用当前本地分支名.
另外,如果不加--abbrev-ref选项,会打印分支head的hash值,而不是打印分支名.
    $ git rev-parse --abbrev-ref new_local_branch@{u}
    aosp/Remote_Branch_U
    $ git rev-parse --abbrev-ref @{u}
    aosp/Remote_Branch_U
    $ git rev-parse @{u}
    66355f171f5ba7dbc66465e761b97afe2395b06e

这个命令可在shell脚本中自动获取到远端服务器分支名,而不是只能用默认值、或者要手动输入.

=====
