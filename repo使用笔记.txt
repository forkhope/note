记录 repo 的使用笔记

===== "repo forall"的 "-p" 选项
当使用"repo forall -c git status"命令来查看各个仓库的git差异时,打印出来的
内容没有包含仓库的名字,有时候根本看不出来某些改动是在哪个仓库.实际上,使用
"repo help forall"命令查看"forall"子命令的帮助信息,可以看到有一个"-p"选项.
其说明为:-p             Show project headers before output
也就是说,加了"-p"选项后,就能在repo forall打印出来的结果中添加上仓库名.
根据帮助信息里面的例子,建议先写"-p",再写"-c",即"repo forall -p -c".

!!!!NOTE!!!!
使用"-p"选项可能会过滤掉一些错误.实际使用中遇到这样一个例子,描述如下:
$ ls       # 下面的brandy目录是后来新增的,原先的repo没有跟踪这个仓库
brandy     linux-3.4    buildroot   tools
$ repo forall -c git pull  # 执行该命令,会看到报错信息,提示有个仓库没有指定
fatal: No remote repository specified.  Please, specify either a URL or a
remote name from which new revisions should be fetched.
Already up-to-date.
Already up-to-date.
Already up-to-date.
$ repo forall -p -c git pull    # 加了"-p"选项后,没有看到上面的报错信息,应
project buildroot/              # 应该是被过滤掉了.可见,使用"-p"选项可能会
Already up-to-date.             # 漏掉某些报错信息.但不加"-p"又打印不出具体
project linux-3.4/              # 的仓库名字.所以要根据实际情况来选择是否使
Already up-to-date.             # 用"-p"选项.
project tools/
Already up-to-date.

===== "repo status"的 "-j" 选项
使用"repo help status"命令查看 "-j" 选项的说明,描述如下:
  -j JOBS, --jobs=JOBS  number of projects to check simultaneously
The -j/--jobs option can be used to run multiple status queries in parallel.
所以,可以使用该选项来加快"repo status"命令的执行速度,如"repo status -j4".

===== "repo sync" 减少同步时间和减小代码空间的选项
可以使用 repo sync -c --no-tags --prune 命令来减少同步时间和减小代码空间.
-c, --current-branch  fetch only current branch from server
    只获取 repo init 时 -b 选项所指定分支,不会获取远端服务器的分支信息.
    例如服务器上新增了其他分支,使用-c选项同步后,本地执行git branch -r
    命令看不到服务器新增的分支名.如果不加-c选项,那么同步的时候,会看到
    "[new branch]"这样的信息,使用git branch -r命令可查看服务器新增的分支.
--no-tags             don't fetch tags
    如注释所说,不获取服务器上的tag信息
--prune               delete refs that no longer exist on the remote
    如果远端服务器上已经删除了某个分支,那么本地也删除对这个分支的跟踪引用.
    查看repo源码,这个选项其实是传给git fetch命令,作为该命令的选项之一.
    查看 man git-fetch 对它自身 --prune 选项的说明如下:
    -p, --prune:
      After fetching, remove any remote-tracking references
      that no longer exist on the remote.

===== "repo sync" 所同步的远端服务器分支
在Android源码目录下,执行 repo help sync 查看sync命令的帮助说明,会看到它没有
参数来指定要同步的远端服务器分支,它默认同步 repo init 时 -b 选项指定的分支.
    Usage: repo sync [<project>...]

当本地分支名和repo init的分支名不同时,执行repo sync会改变本地分支指向.
使用 git branch 命令,打印当前分支名是 branch_m
  $ git branch
    other_branch_xxx
  * branch_m
在当前代码目录下执行repo sync命令
  $ repo sync .
  Fetching project platform/packages/apps/Settings
  packages/apps/Settings/: leaving branch_m; does not track upstream
再次执行git branch命令,会看到当前处于没有命名的分支下
  $ git branch
  * (detached from f15a7be)
    other_branch_xxx
    branch_m

基于这个现象,建议在本地所有分支名跟服务器分支名都相同时,才用repo sync来同步
代码.避免同步之后,分支指向发生变化,此时修改的代码不是位于原来分支下面,后续
如果要commit到原来的分支,会提示需要merge,容易造成代码冲突.

===== "repo sync" 的 <project> 参数
repo sync默认同步所有git仓库,可以提供一个或多个 <project> 参数来指定需要
同步的git仓库路径. 关键是,如何知道某个git仓库的 <project> 参数值是多少.

经过实际测试发现,这里提供的<project>参数值是基于shell当前的工作目录寻址
到目标git仓库的目录路径,而不是git仓库在repo中保存的完整路径.

例如 repo status 打印了下面的git仓库信息.可以看到,这个git仓库在repo中
保存的完整路径是 "android/packages/apps/Settings/".
    project android/packages/apps/Settings/ branch branch_m
     -m     res/values-zh-rCN/strings.xml
然后在"android/"目录下执行repo sync -d android/packages/apps/Settings/会报错.
    $ repo sync -d android/packages/apps/Settings/
    error: project android/packages/apps/Settings/ not found
即,执行命令时,shell的工作目录在android目录下,然后传入git仓库的
完整目录路径 "android/packages/apps/Settings/",repo sync会报错.

而传入 packages/apps/Settings/ 这个路径就可以正常执行.
$ repo sync -d packages/apps/Settings/
Fetching project platform/packages/apps/Settings/

如果本身已经在 android/packages/apps/Settings/下面,直接执行"repo sync ."即可
$ repo sync .
Fetching project platform/packages/apps/Settings/

总的来说,repo sync 后面跟着的project参数值应该是基于当前shell工作目录能够
寻址到该project的目录路径,类似于cd命令的寻址方式.

查看 repo help sync 对 project 参数的说明如下,符合上面的验证结果.
'repo sync' will synchronize all projects listed at the command line.
Projects can be specified either by name, or by a relative or absolute
path to the project's local directory. If no projects are specified,
'repo sync' will synchronize all projects listed in the manifest.
基于这个说明,可以提供 project name、project本地目录的相对路径或绝对路径
来指定要同步的project.

这里说的 project name 可以在 repo 生成的 .repo/ 目录下查看.
查看这个目录下的 manifest.xml 文件,有如下信息:
<project groups="p-fs-release,pdk-fs" name="platform/packages/apps/Settings"
    path="android/packages/apps/Settings"  />
可以看到Settings project 的name 是 platform/packages/apps/Settings.
那么不管在哪个目录下,执行 repo sync platform/packages/apps/Settings 命令
都会同步Settings目录的代码.

===== "repo sync"的 "-d" 选项
使用 repo sync 来同步代码时,如果本地修改了代码还没有commit,会提示无法sync:
  error: android/frameworks/base/: contains uncommitted changes

如果想要强制同步远端服务器代码,可以加上 -d 选项,repo sync -d 会将HEAD强制指向
manifest的库,而忽略本地的改动.查看 repo help sync 对 -d 选项的说明如下.
  -d, --detach          detach projects back to manifest revision

注意: 加上 -d 选项只表示忽略本地改动,可以强制同步服务器代码,
但是本地改动的文件还是保持改动不变,不会强制覆盖掉本地修改.
而且执行之后,本地的分支指向会发生变化,不再指向原来的分支.具体举例如下.

下面是执行 repo sync -d 之前的分支信息
    $ git branch
    * curent_branch_xxx
下面是执行 repo sync -d 之后的分支信息
    $ git branch
    * (detached from 715faf5)
      curent_branch_xxx
用 git status 查看,可以看到本地还是有修改过且还没有commit的文件,
同步服务器代码后,并不会强制覆盖本地文件为服务器的代码
    $ git status
    HEAD detached at 715faf5
    Changes not staged for commit:
      (use "git add <file>..." to update what will be committed)
      (use "git checkout -- <file>..." to discard changes in working directory)
            modified:   vendor/chioverride/default/g_pipelines.h
            modified:   vendor/topology/g_usecase.xml

即,如果想要丢弃本地修改、让本地代码跟git仓库代码一致,repo sync -d达不到这个效果.

另外, repo sync 有一个 --force-sync 选项:
  --force-sync          overwrite an existing git directory if it needs to
                        point to a different object directory. WARNING: this
                        may cause loss of data
从说明来看,像是可以强制同步,可能会丢失本地改动.但是实际测试发现,这个选项
并不会强制覆盖本地的改动.如果本地文件被改动,加上这个选项也会sync报错:
    $ repo sync --force-sync .
    Fetching project tools/
    error: tools/: contains uncommitted changes

同时提供 -d 和 --force-sync 两个选项,还是不会强制覆盖本地修改.
目前没有找到 repo sync 命令可以强制覆盖本地修改的选项.

===== 用repo丢弃本地修改,强制同步远端服务器代码
目前所知,使用 repo sync 同步远端服务器代码,不能强制覆盖本地修改.
如果想要强制覆盖本地修改,可以用 repo forall -c 来执行git丢弃本地
修改的命令,git checkout 和 git reset 命令都可以丢弃本地修改.

一般来说,可以使用 "git checkout ." 命令来丢弃当前目录下的改动,但是
实际执行 "repo forall -c git checkout ." 命令会报错.
    $ repo forall -c git checkout .
    error: pathspec '.' did not match any file(s) known to git.

而使用 repo forall -c 'git reset --hard' 命令不会报错,可以用这个命令来
丢弃所有git仓库的本地改动,然后再用 repo sync 命令来同步远端服务器代码.

在实际开发时,可能会在本地创建开发分支,这个分支没有关连到服务器分支.
我们同步远端服务器代码,可能只是想获取到最新代码.此时,并不想丢弃本地
开发分支的改动.如果用上面的命令无法区分这种情况,会丢弃开发分支的改动.

下面这个看起来很复杂的命令就用于解决这个问题,它先判断当前本地分支在
远端服务器存在同名分支,才强制覆盖本地修改并pull服务器代码.
repo forall -c "branch_name=$(git rev-parse --abbrev-ref HEAD) && git rev-parse --abbrev-ref ${branch_name}@{upstream} && git reset --hard && git pull --stat --no-tags" |& cat

对这个命令的各个部分说明如下.
repo forall -c: 对所有git仓库都执行后面的跟着的命令,这里使用双引号把
    多个git命令都括起来,作为一个整体传给repo,可以做一些复杂的操作.
branch_name=$(git rev-parse --abbrev-ref HEAD): 这是bash shell的语法,
    $(cmd)会执行cmd命令,得到它的输出,这里把输出结果赋值给branch_name
    变量.git rev-parse --abbrev-ref HEAD 命令输出且只输出本地分支名.
&&: bash shell的与操作,前一个命令执行结果为true,才会执行下一个命令.
git rev-parse --abbrev-ref ${branch_name}@{upstream}: ${var} 获取var
    变量的值.branch_name变量在前面被赋值为当前本地分支名.这整个git
    命令获取本地分支在远端服务区分支名.如果获取不到,执行结果是false.
git reset --hard: 基于&&操作符的特性,如果上一个git命令获取不到本地分
    支在远端服务器的分支名,就不会往下执行.所以执行到这里时,说明本地
    分支名跟远端服务器分支名相同,我们假设本地开发分支没有关连到远端
    服务器分支,那么当前分支就不是开发分支,用git reset丢弃本地修改.
git pull --stat --no-tags: 同步服务器代码,--stat表示要打印发生改动的
    文件信息,--no-tags表示不获取远端服务器仓库的tag信息.可不加选项.
|& cat: 把整个repo命令的标准输出、错误输出都重定向到cat命令.如果不重
    定向,repo会用less命令来显示输出内容,需要手动按q退出才会继续输出,
    重定向到cat后,直接打印全部输出内容,不需要再手动进行其他操作.

=====
